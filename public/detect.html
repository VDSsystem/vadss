<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detect Accidents</title>
    <link rel="stylesheet" href="../css/cssStyle.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>

</head>
<body class="detectBody">
    <header class="detectHeader">
        <a href="main.html">HOME</a>
    </header>
    <main class="detectMain">
        <h1>Please select a picture to determine whether an accident occur or not</h1>
        <form action="#" class="uploadForm">
            <input type="file" name="file" id="file" class="file">
          </form>
          <button class="upload" onclick="handleImage()">Upload Image</button>
        <section class="result">
        </section>
        <script>
            let model = null;
            let loading = 0;
            const labels = [
                        "Accident",
                        "nonAccident"
                    ];

            async function loadModel() {
                model = await tf.loadGraphModel("https://raw.githubusercontent.com/VDSsystem/yolov5/main/model.json");
                console.log('Model loaded successfully!');
                const dummy = tf.ones(model.inputs[0].shape);
                const res = await model.executeAsync(dummy);
    
                // clear memory
                tf.dispose(res);
                tf.dispose(dummy);
                console.log("Done");
            }
            window.addEventListener('DOMContentLoaded', (event) => {
                         loadModel();
                    });
                    
            const fileInput = document.getElementById('file');
            function handleImage() {
                 const file = fileInput.files[0];
                        if (!file) {
                             console.log('No file selected.');
                        return;
                }
                handleUpload(file);
            }
            const imageRef = document.createElement('img');
            const canv = document.createElement('canvas');
            canv.id = 'canvas';
            const result = document.querySelector('.result');
            document.body.appendChild(imageRef);
            document.body.appendChild(canv);
            


                function handleUpload(file) {
                        const src = window.URL.createObjectURL(file);
                        imageRef.src = src;
                        imageRef.onload = () => {
                            doPredictImage();
                            window.URL.revokeObjectURL(src);
                        }
                        
                        result.innerHTML = '';
                        result.appendChild(imageRef);
                        
                    console.log(`Uploaded file: ${file.name}`);
                }
                async function doPredictImage(){
                    tf.engine().startScope();
                    const [modelWidth, modelHeight] = model.inputs[0].shape.slice(1, 3);
                    const input = tf.tidy(() => {
                        const imageTensor = tf.browser.fromPixels(imageRef);
                        return tf.image.resizeBilinear(imageTensor, [modelWidth, modelHeight]).div(255.0).expandDims(0);
                    });
                    const res = await model.executeAsync(input);

                    const [boxes, scores, classes] = res;
                    const boxesData = boxes.dataSync();
                    const scoresData = scores.dataSync();
                    const classesData = classes.dataSync();
                    renderPrediction(boxesData, scoresData, classesData);
                    console.log("boxes" + boxes + " scores" + scores + " classes" + classes);
                    // clear memory
                    tf.dispose(res);

                    tf.engine().endScope();

                }
                const renderPrediction = (boxesData, scoresData, classesData) => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext("2d");
  canvas.style.backgroundColor = 'transparent';


  // clean canvas
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  const font = "16px sans-serif";
  ctx.font = font;
  ctx.textBaseline = "top";

  for (let i = 0; i < scoresData.length; ++i) {
    const klass = labels[classesData[i]];

    const score = (scoresData[i] * 100).toFixed(1);

    let [x1, y1, x2, y2] = boxesData.slice(i * 4, (i + 1) * 4);
    x1 *= canvas.width;
    x2 *= canvas.width;
    y1 *= canvas.height;
    y2 *= canvas.height;
    const width = x2 - x1;
    const height = y2 - y1;

    // draw the bounding box
    ctx.strokeStyle = "#C53030";
    ctx.lineWidth = 2;
    ctx.strokeRect(x1, y1, width, height);

    const label = klass + " - " + score + "%";
    const textWidth = ctx.measureText(label).width;
    const textHeight = parseInt(font, 10); // base 10

    // draw the label background
    ctx.fillStyle = "#C53030";
    ctx.fillRect(x1 - 1, y1 - (textHeight + 4), textWidth + 6, textHeight + 4);

    // draw the label text
    ctx.fillStyle = "#FFFFFF";
    ctx.fillText(label, x1 + 2, y1 - (textHeight + 2));
    result.innerHTML = '';
    result.appendChild(canv);
    
  }
}
            
        </script>
    </main>
</body>
</html>